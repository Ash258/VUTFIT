V naší matematické knihovně pracujeme výhradně s knihovnou Apfloat, proto jsme ji použili i v našem profileru. Mohly jsme udělat rozhraní pro základní aritmetické funkce, ale java neumožňuje definovat inline funkce, takže bychom neměli jistotu, že by nebyla zbytečená řežie za volání těchto funkcí, které by pouze delegovali výpočet. Proto tuto knihovnu voláme v profileru přímo. Při požadavku pro větší abstrakci matematických výpočtu by se musela definovat rozhraní pro operace, výsledky a musely by se napsat buď adaptéry pro některou implementaci, nebo vlastní implementace. Toto řešení nám přišlo zbytečné pro podstatu projektu.

Základní optimalizce by spočívala v odstranění celé knihovny Apfloat, která má velkou režii při výpočtech. Zkoušeli jsme profiling provést pouze s primitivním datovým typem double. Při výpočtu se používají pouze druhé mocniny, na které stačí použít jedno násobení. Takže jedinou složitou funkcí byla druhá odmocnina, kterou jsme zkoušeli s java.lang.Math knihovnou. Rozdíl byl enormní, ale docházelo k menší přesnosti výpočtu.

Další nepatrnou optimalizací by bylo načítat čísla ze souboru přes java.util.stream (pipeline implementace) a zároveň počítat výsledky. Nealokalovala by se zbytečně najednou celá paměť a nečekalo by se na inicializaci listu, proces by byl kotinuální skrz iteraci listu.

Další nepatrnou optimalizací by mohla být mezipaměť výsledků druhé mocniny, kterou voláme v každé iteraci cyklu. Mohla by se mapovat hodnota v cyklu a výsledek pro tuto hodnotu. Pokud je již hodnota spočítána, pak se použije výsledek. Apfloat je immutable při výpočtech, proto bychom mohli používat uložené hodnoty. Tato optimalizace je výhodná pouze pro vstupy, kde se často opakují hodnoty. Může to být ale také značné zpomalení kvůlii režii s mapou pro malé nebo rozdílné hodnoty.